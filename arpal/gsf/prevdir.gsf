*function main(args)
* rc = gsfallow('on')
* rc = gsfpath('/usr/share/grads/lib/gsf')
* _DEBUG=0
* _INFO=0
*
*#-- INPUT
*#-- exprx: componente X
*#-- expry: componente Y
*#-- nsec: numero di settori, di default 8
*#-- opt: se vale 'wind' (default) calcola la direzione di provenienza anziche' quella di arrivo
*#-- opt: se vale 'wave' calcola la direzione di arrivo
*#-- filter: se vale 1 applica il filtro di smoothing, default: 0
* i=0;
* i=i+1;exprx=subwrd(args,i)
* i=i+1;expry=subwrd(args,i)
* i=i+1;nsec=subwrd(args,i)
* i=i+1;opt=subwrd(args,i)
* i=i+1;filter=subwrd(args,i)
* i=i+1;thirdD=subwrd(args,i)
* i=i+1;third1=subwrd(args,i)
* i=i+1;third2=subwrd(args,i)
* say prevdir(exprx,expry,nsec,opt,filter,thirdD,third1,third2)
*return
*
#---------------------------------------
#-- dato un dataset di U e V (exprx,expry) torna la direzione prevalente suddividendo le direzioni in nsec settori
#-- se opt vale 'wind' (default) calcola la direzione di provenienza, altrimenti quella di arrivo
#-- se filter vale 1 applica il filtro WMO (ha senso solo per serie temporali in un unico punto)
#-- se third e' valorizzata contiene la terza varying dimension aggiuntiva: lo funzione accetta solo 1D o 2D, per il 3D si usa third
#--   sintassi di esempio: 'T 1 3' 'E 2 7' 'Z 2 3'
function prevdir(exprx,expry,nsec,opt,filter,thirdD,third1,third2)
 if(exprx='help')
  say 'uso: prevailingDir exprx[u|u10|...] expry[v|v10|...] nsec[8...] opt[wind|wave] filter[0|1] thirdD[0|T|E|Z|X|Y] third1 third2'
  say '     il primo argomento proposto e` il default (u v 8 wind 0)'
  say '     thirdD e` l`eventuale varying dimension aggiuntiva [0|T|E|Z|X|Y], se 0 non viene considerata, third1 e third2 sono i suoi valori (interi)'
  return -999
 endif
 if(_DEBUG='_DEBUG');_DEBUG=0;endif
 if(_INFO='_INFO');_INFO=0;endif
 if(exprx='' | exprx='exprx');exprx='u';endif
 if(expry='' | expry='expry');expry='v';endif
 if(nsec='' | nsec='nsec');nsec=8;endif
 if(opt='' | opt='opt');opt='wind';endif
 if(filter='' | filter='filter');filter=0;endif
 if(thirdD='' | thirdD='thirdD');thirdD=0;endif
 if(opt!='wind' & opt!='wave')
  say '!!! prevdir FATAL: opt must be wind|wave while opt='opt
  return -999
 endif
#-- third checks
 if(thirdD)
  if(thirdD='t');thirdD='T';endif
  if(thirdD!='T' & thirdD!='Z' & thirdD!='E' & thirdD!='X' & thirdD!='Y')
   say '!!! prevdir FATAL - thirdD='thirdD' INVALID'
   return -999
  endif
  if(valnum(third1)!=1)
   say '!!! prevdir FATAL - third1='third1' INVALID'
   return -999
  endif
  if(valnum(third2)!=1)
   say '!!! prevdir FATAL - third2='third2' INVALID'
   return -999
  endif
  'q dims'
  i=0;while(i<10);i=i+1
   line=sublin(result,i)
   dim=subwrd(line,1)
   status=subwrd(line,3)
   if(dim=thirdD)
    if(status!='fixed')
     say '!!! prevdir FATAL - thirdD='thirdD' already in status='status
     return -999
    endif
    break
   endif
  endwhile
 endif

#-- gestisco third
 if(thirdD)
  if(third1=third2)
#-- trovo le frequenze dei settori e le metto in un vettore a stringa
   'set 'thirdD' 'third1
   string=getSecFreq(exprx,expry,nsec,opt)
   if(_INFO);say 'array at 'thirdD'='third1': 'string;endif
  else
   third=third1-1;while(third<third2);third=third+1
    'set 'thirdD' 'third
#-- trovo le frequenze dei settori e le metto in un vettore a stringa
    string0=getSecFreq(exprx,expry,nsec,opt)
    if(_INFO);say 'array at 'thirdD'='third': 'string0;endif
    if(string1='string1' | string1='')
     string1=string0
    else
     len=linlen(string0)
     i=0;while(i<len);i=i+1
      el0=subwrd(string0,i)
      el1=subwrd(string1,i)
      el=el0+el1
      if(i=1)
       string=el
      else
       string=string' 'el
      endif
     endwhile
    endif
   endwhile
  endif
 else
#-- trovo le frequenze dei settori e le metto in un vettore a stringa
  string=getSecFreq(exprx,expry,nsec,opt)
 endif
 if(_INFO);say 'string:' string;endif

#-- definisco le direzioni dei settori
 i=1;dir.i='Calm';ddir.i='-'
 width=360/nsec
 l1=-180+width
 strDdir=ddir.i
 strDir=dir.i
 while(i<=nsec);i=i+1
  dir.i=l1
  if(dir.i=0);ddir.i='N';endif
  if(dir.i=22.5);ddir.i='NNE';endif
  if(dir.i=45);ddir.i='NE';endif
  if(dir.i=67.5);ddir.i='ENE';endif
  if(dir.i=90);ddir.i='E';endif
  if(dir.i=112.5);ddir.i='ESE';endif
  if(dir.i=135);ddir.i='SE';endif
  if(dir.i=157.5);ddir.i='SSE';endif
  if(dir.i=180);ddir.i='S';endif
  if(dir.i=-157.5);ddir.i='SSW';endif
  if(dir.i=-135);ddir.i='SW';endif
  if(dir.i=-112.5);ddir.i='WSW';endif
  if(dir.i=-90);ddir.i='W';endif
  if(dir.i=-67.5);ddir.i='ENW';endif
  if(dir.i=-45);ddir.i='NW';endif
  if(dir.i=-22.5);ddir.i='NNW';endif
  l1=l1+width
  strDdir=strDdir' 'ddir.i
  strDir=strDir' 'dir.i
 endwhile
 nvalid=0
 i=0;while(i<=nsec);i=i+1
  nel=subwrd(string,i)
  nvalid=nvalid+nel
  if(_INFO);say 'INFO - dir.'i'='dir.i' ('ddir.i') nel='nel;endif
 endwhile

#-- verifico che la calma non sia un massimo (altrimenti prevale la calma)
 found=0
 imax1=1
 max=getMax(string)
 maxS=subwrd(string,imax1)
 if(_INFO);say 'array:'string'  max:'max'  ('strDdir')';endif
 if(maxS=max)
  found=1
  dirp=dir.imax1
  if(_INFO);say 'max='maxS'/'nvalid' sector='imax1' dir='dirp;endif
 else
#-- escludo le calme dal vettore stringa
  string=shift(1,string)
  strDdir=shift(1,strDdir)
  strDir=shift(1,strDir)
#-- filtro i dati
  if(filter);string=circularFilter(string);endif
#-- trovo il/i massimi
  imax=getMaxPos(string)
  imax1=subwrd(imax,1)
  imax2=subwrd(imax,2)
  imax3=subwrd(imax,3)
  if(_INFO);say 'imax='imax' imax1='imax1' imax2='imax2' imax3='imax3;endif
#-- ho un solo max: e' quello
  if(imax2='')
   found=1
   dirp=subwrd(strDir,imax1)
   ddirp=subwrd(strDdir,imax1)
   if(_INFO);say '1 max='%subwrd(string,imax1)%'/'nvalid' sector='imax1' dir='dirp' ('ddirp')';endif
  else
#-- ho due max uguali: li considero se sono contigui (caso 1-2, ..., 7-8)
   if(imax3='' & imax1>0 & imax2=imax1+1)
    found=1
    dirp=subwrd(strDir,imax1)+width/2
    ddirp=subwrd(strDdir,imax1)'/'subwrd(strDdir,imax2)
    if(_INFO);say '2 max:'%subwrd(string,imax1)%'/'nvalid','%subwrd(string,imax2)%'/'nvalid' sectors='imax1','imax2' dir='dirp' ('ddirp')';endif
   endif
#-- ho due max uguali: li considero se sono contigui (caso 1-8)
   if(imax3='' & imax1>0 & imax2-imax1=nsec-1)
    found=1
    dirp=subwrd(strDir,imax1)+width/2
    ddirp=subwrd(strDdir,imax1)'/'subwrd(strDdir,imax2)
    if(_INFO);say '2 max='%subwrd(string,imax1)%'/'nvalid' sector='imax1' dir='dirp' ('ddirp')';endif
   endif
  endif
 endif
#-- se ho piu' di due max o se ne ho due non contigui o se ne ho due di cui uno e' la calma rinuncio
 if(!found)
  dirp='Variable'
  if(_INFO);say '0 max='%subwrd(string,imax1)%'/'nvalid' no prevalent sector found';endif
 endif
#-- trasformo la dir dal range -180 180 in 0 360
 if(valnum(dirp))
  dirp=math_mod(dirp+360,360)
 endif
#-- uso la codifica DB: trasformo lo 0 in 360, le calme in 0, le variabili in -1
 if(dirp=0);dirp=360;endif
 if(dirp='Calm');dirp=0;endif
 if(dirp='Variable');dirp=-1;endif
 if(_INFO);say '>>> dirp='dirp;endif
 'set gxout contour'
 'set gxout value'
return dirp

#-----------------------------------------------------------------
#-- trovo le frequenze dei settori e le metto in un vettore a stringa
function getSecFreq(exprx,expry,nsec,opt)
#-- trovo i settori
#-- ipotesi 8 settori
#--   settore 1: calma di vento
#--   settore 2: vento che proviene da S
#--   settore 3: vento che proviene da SW
#--   settore 4: vento che proviene da W
#--   settore 5: vento che proviene da NW
#--   settore 6: vento che proviene da N
#--   settore 7: vento che proviene da NE
#--   settore 8: vento che proviene da E
#--   settore 9: vento che proviene da SE
#--   width ampiezza settori
#-- variabile ddd: direzione di provenienza del vento o propagazione delle onde, in gradi
#-- nvalid: numero di elementi complessivi
#-- nvalid.i: numero di elementi che appartengono al settore i (i=1,2,...,9)
#-- dir.i: direzione centrale del settore i
 width=360/nsec
* if(_INFO);say 'INFO - nsec:'nsec' width:'width;endif
* if(_INFO);say 'INFO - define ddd=atan2d('exprx','expry','opt')';endif
 'define ddd=atan2d('exprx','expry','opt')'
 nvalid=stat('ddd','valid')
#-- escludo le calme da ddd
 'define ddd=maskout(ddd,mag('exprx','expry')-0.5)'
#-- settore Calm
 i=1
 nvalid.i=stat('ddd','undef')
 dir.i='Calm'
* if(_INFO);say 'INFO - nel='nvalid.i' sector='i' dir='dir.i;endif
#--   altri settori
 l1=-180-width/2
 i=1;while(i<=nsec);i=i+1
  l1=l1+width
  if(i=1)
   l2=-1*l1
   sector='inside(ddd,'l1','l2',outside,-u,=<)'
  l1=l1-width
  else
   l2=l1+width
   sector='inside(ddd,'l1','l2',inside,-u,<=)'
  endif
  nvalid.i=stat(sector,'valid')
  dir.i=l1+width/2
*  if(_INFO);say 'INFO - nel='nvalid.i' sector='i' dir='dir.i;endif
 endwhile
 'undefine ddd'
#-- trasformo il vettore in stringa
 string=''
 i=0;while(i<=nsec);i=i+1
  if(string='');string=nvalid.i;else;string=string' 'nvalid.i;endif
 endwhile
return string

#-----------------------------------------------------------------
#-- accetta un vettore (stringa) senza le calme lo trasforma in un vettore circolare, applica il filtro e ritorna il vettore filtrato 
#-- funzione ad uso esclusivo di prevailingDir
function circularFilter(array)
 nsec=linlen(array)
 filtered=''
 i=0;while(i<nsec)
*  valp2=getStrArrVal(array,math_mod(i+2,nsec))
  im2=math_mod(nsec+i-2,nsec)
  im1=math_mod(nsec+i-1,nsec)
  ip1=math_mod(i+1,nsec)
  ip2=math_mod(i+2,nsec)
  if(_INFO);say 'INFO filter index i: 'im2' 'im1' 'i' 'ip1' 'ip2;endif
  valm2=getStrArrVal(array, im2)
  valm1=getStrArrVal(array,im1)
  valp0=getStrArrVal(array,i)
  valp1=getStrArrVal(array,ip1)
  valp2=getStrArrVal(array,ip2)
#--   Xf(i) = 1/9*X(i-2) + 2/9*X(i-1) + 3/9*X(i) + 2/9*X(i+1) + 1/9*X(i+2)
  val=1/9*valm2 + 2/9*valm1 + 3/9*valp0 + 2/9*valp1 + 1/9*valp2
  val=math_format('%.2f',val)
  if(_INFO);say 'INFO filter v: 'valm2' 'valm1' 'valp0' 'valp1' 'valp2' -> 'val;endif
  if(filtered='');filtered=val;else;filtered=filtered' 'val;endif
  i=i+1
 endwhile
 if(_INFO);say 'INFO before filter array is: 'array;endif
 if(_INFO);say 'INFO  after filter array is: 'filtered;endif
return filtered

#-----------------------------------------------------------------
#-- torna la word index+1 della stringa array
#-- serve per poter mantenere l'array con indice 0...N-1 mentre le subwrd vanno variano come 1...N
function getStrArrVal(array,index)
* say array ' - 'index
return subwrd(array,index+1)
